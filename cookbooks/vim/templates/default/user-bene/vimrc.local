"-----------------------------------------------------------------------
" global settings
"-----------------------------------------------------------------------

" personal leader key
let mapleader = ","

" Set GUI window size
if has("gui_running")
	set lines=50
	set columns=150
endif

" use the wildmenu
set wildmenu
set wildmode=full
"
" reload files changed outside of vim
set autoread

" no backup files (we have git after all)
set nobackup

" easy pasting
set pastetoggle=<F4>

"-----------------------------------------------------------------------
" plugin settings
"-----------------------------------------------------------------------

" conque
let g:ConqueTerm_FastMode = 0
let g:ConqueTerm_Color = 2
let g:ConqueTerm_ReadUnfocused = 1
let g:ConqueTerm_InsertOnEnter = 1
let g:ConqueTerm_CWInsert = 1
let g:ruby_conque_rspec_command='bundle exec rspec -cfs'
let g:ruby_conque_window_height=20

" ctrlp
let g:ctrlp_max_height = 30

" powerline
let g:Powerline_symbols = 'fancy'

" selectbuf
let g:selBufAlwaysHideBufNums = 1

" supertab
let g:SuperTabDefaultCompletionType = "<C-X><C-O>"
highlight Pmenu ctermbg=238 gui=bold

" syntastic
let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_mode_map = { 'mode': 'active',
                           \ 'active_filetypes': [],
                           \ 'passive_filetypes': ['c', 'cpp'] }

" taglist
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_Close_On_Select = 1
let Tlist_Highlight_Tag_On_BufEnter = 0
let Tlist_Sort_Type = "name"

" vimux
let g:VimuxHeight = "33"

"-----------------------------------------------------------------------
" auto commands
"-----------------------------------------------------------------------

" expand tabs in C
autocmd FileType c,cpp set ts=4 sw=4 tw=79 expandtab et

" ruby completion
autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

" all remaining filetypes use syntaxcomplete
autocmd Filetype *
			\ if &omnifunc == "" |
			\   setlocal omnifunc=syntaxcomplete#Complete |
			\ endif

" remember the git root of the current project
autocmd VimEnter,BufEnter * let b:git_root_dir = system("git rev-parse --show-toplevel 2>/dev/null")[:-2]

" use project-level tagfiles
autocmd VimEnter,BufEnter * execute("set tags=./tags," . b:git_root_dir . "/tags")

" close nerdcommenter if its the last window
autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" delete fugitive buffers
autocmd BufReadPost fugitive://* set bufhidden=delete

"-----------------------------------------------------------------------
" custom functions
"-----------------------------------------------------------------------

" shortcut for file rename
function! RenameFile()
	let old_name = expand('%')
	let new_name = input('New file name: ', expand('%'), 'file')
	if new_name != '' && new_name != old_name
		exec ':saveas ' . new_name
		exec ':silent !rm ' . old_name
		redraw!
	endif
endfunction

" git-grep function
if !exists('g:git_grep_command')
	let g:git_grep_command = 'git grep -n '
endif

function! s:GitGrep(terms)
	let expr = g:git_grep_command."'".a:terms."'"

	execute ":silent! lcd " . b:git_root_dir
	cgetexpr system(expr)
	execute ":silent! lcd " . expand("%:p:h")

	cwin
	echo 'Number of matches: ' . len(getqflist())
endfunction

function! s:GitGrepWord()
	call s:GitGrep(expand("<cword>"))
endfunction

function! s:GitGrepWordBoundaries()
	call s:GitGrep("\\b".expand("<cword>")."\\b")
endfunction

command! -nargs=0 GitGrepWordBoundaries :call s:GitGrepWordBoundaries()
command! -nargs=0 GitGrepWord :call s:GitGrepWord()
command! -nargs=+ GitGrep :call s:GitGrep(<q-args>)

"-----------------------------------------------------------------------
" key mappings
"-----------------------------------------------------------------------

" disable arrow keys
map <up> <nop>
map <down> <nop>
map <left> <nop>
map <right> <nop>
imap <up> <nop>
imap <down> <nop>
imap <left> <nop>
imap <right> <nop>

" function keys
nnoremap <silent> <F1> :help<cr>
nnoremap <silent> <F2> :call RenameFile()<cr>
" nnoremap <F3> :SelectBuf<cr>
nnoremap <silent> <F4> :set invpaste<cr>
nnoremap <silent> <F5> :call system("ctags -R --c++-kinds=+p --fields=+iaS --extra=+q -f " . b:git_root_dir . "/tags " . b:git_root_dir)<cr>
nnoremap <silent> <F6> :TlistToggle<cr>
" nnoremap <F8> toggle terminal input mode
" vnoremap <F9> send a visually selected range of text to an existing terminal buffer
" nnoremap <F10> send the entire contents of the file to an existing terminal buffer
" nnoremap <F11> execute the current file in a new terminal buffer
nnoremap <silent> <F12> :GundoToggle<cr>

" window movement
map <S-Down> <C-W><Down>
map <S-Up> <C-W><Up>
map <S-Left> <C-W><Left>
map <S-Right> <C-W><Right>

" tab switching
map  <silent> <C-Up> :tabprevious<cr>
imap <silent> <C-Up> <esc>:tabprevious<cr>
map  <silent> <C-Down> :tabnext<cr>
imap <silent> <C-Down> <esc>:tabnext<cr>

" map Ctrl-N to write+next
imap <C-n> <esc>:w<cr>:n<cr>
map <C-n> :w<cr>:n<cr>

" jump to next merge conflict
map <leader>fc /^<<<<<cr>

" (visual) paste without losing the register
xnoremap P Pgvy

" Bubble single lines
nmap <C-k> ddkP
nmap <C-j> ddp

" Bubble multiple lines
vmap <C-k> xkP`[V`]
vmap <C-j> xp`[V`]

" git grep for word under the cursor
nmap <silent> <leader>gw :GitGrepWordBoundaries<CR>
nmap <silent> <leader>gW :GitGrepWord<CR>

" disable search hilight
nmap <silent> <leader>n :silent :nohlsearch<cr>

" cleanup whitespace terror
nmap <silent> <leader>ws :set et<cr>:retab<cr>:%s/\s\+$//g<cr>

" sort helper
vmap <silent> <leader>so :sort<cr>
vmap <silent> <leader>su :sort u<cr>

" git shortcuts
map <leader>gb :silent :Gblame<cr>

""" shortcuts below here haven't been used in quite a while, maybe i should
""" remove them ...

" rails shortcuts
map <leader>rc :Rcontroller<cr>
map <leader>rh :Rhelper<cr>
map <leader>rm :Rmodel<cr>
map <leader>rv :Rview<cr>

" add ruby debugger
nnoremap <silent> <leader>rad Orequire 'debugger'; debugger<esc>

" vimux
map <leader>vp :silent :VimuxPromptCommand<cr>
map <leader>vi :silent :VimuxInspectRunner<cr>
map <leader>vq :silent :VimuxCloseRunner<cr>
map <leader>vx :silent :VimuxClosePanes<cr>
map <leader>vs :silent :VimuxInterruptRunner<cr>

" run tests
map <silent> <leader>t :silent :w<cr>:call VimuxRunCommand("PS1='${RESET}'; clear; rspec --drb " . expand("%:p"))<cr>
map <silent> <leader>T :silent :w<cr>:call VimuxRunCommand("PS1='${RESET}'; clear; rspec --drb " . expand("%:p") . ":" . line("."))<cr>

" tag search
nnoremap <silent><Leader><C-]> <C-w><C-]>
nnoremap <silent><C-]> g<C-]>

" use sudo for writing
cmap w!! w !sudo tee % >/dev/null

" Rename tabs to show tab# and # of viewports
if exists("+showtabline")
	function MyTabLine()
		let s = '' " complete tabline goes here
		" loop through each tab page
		for t in range(tabpagenr('$'))
			" select the highlighting for the buffer names
			if t + 1 == tabpagenr()
				let s .= '%#TabLineSel#'
			else
				let s .= '%#TabLine#'
			endif
			" empty space
			let s .= ' '
			" set the tab page number (for mouse clicks)
			let s .= '%' . (t + 1) . 'T'
			" set page number string
			let s .= t + 1 . ' '
			" get buffer names and statuses
			let n = ''  "temp string for buffer names while we loop and check buftype
			let m = 0 " &modified counter
			let bc = len(tabpagebuflist(t + 1))  "counter to avoid last ' '
			" loop through each buffer in a tab
			for b in tabpagebuflist(t + 1)
				" buffer types: quickfix gets a [Q], help gets [H]{base fname}
				" others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
				if getbufvar( b, "&buftype" ) == 'help'
					let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
				elseif getbufvar( b, "&buftype" ) == 'quickfix'
					let n .= '[Q]'
				else
					let n .= pathshorten(fnamemodify(bufname(b), ':~'))
				endif
				" check and ++ tab's &modified count
				if getbufvar( b, "&modified" )
					let m += 1
				endif
				" no final ' ' added...formatting looks better done later
				if bc > 1
					let n .= ' '
				endif
				let bc -= 1
			endfor
			" add modified label [n+] where n pages in tab are modified
			if m > 0
				"let s .= '[' . m . '+]'
				let s.= '+ '
			endif
			" add buffer names
			if n == ''
				let s .= '[No Name]'
			else
				let s .= n
			endif
			" switch to no underlining and add final space to buffer list
			"let s .= '%#TabLineSel#' . ' '
			let s .= ' '
		endfor
		" after the last tab fill with TabLineFill and reset tab page nr
		let s .= '%#TabLineFill#%T'
		" right-align the label to close the current tab page
		if tabpagenr('$') > 1
			let s .= '%=%#TabLine#%999XX'
		endif
		return s
	endfunction
	set stal=2
	set tabline=%!MyTabLine()
endif
