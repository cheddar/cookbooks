"-----------------------------------------------------------------------
" global settings
"-----------------------------------------------------------------------

" personal leader key
let mapleader = ","

" Set GUI window size
if has("gui_running")
    set lines=50
    set columns=150
endif

" use the wildmenu
set wildmenu
set wildmode=full
"
" reload files changed outside of vim
set autoread
set autowriteall

" no backup files (we have git after all)
set nobackup

" easy pasting
set pastetoggle=<F4>

"-----------------------------------------------------------------------
" plugin settings
"-----------------------------------------------------------------------

" conque
let g:ConqueTerm_FastMode = 0
let g:ConqueTerm_Color = 2
let g:ConqueTerm_ReadUnfocused = 1
let g:ConqueTerm_InsertOnEnter = 1
let g:ConqueTerm_CWInsert = 1
let g:ruby_conque_rspec_command = 'bundle exec rspec -cfs'
let g:ruby_conque_window_height = 10

" ctrlp
let g:ctrlp_max_height = 30

" powerline
let g:Powerline_symbols = 'fancy'

" selectbuf
let g:selBufAlwaysHideBufNums = 1

" supertab
let g:SuperTabDefaultCompletionType = "<C-X><C-O>"
highlight Pmenu ctermbg=238 gui=bold

" syntastic
let g:syntastic_auto_jump=1
let g:syntastic_auto_loc_list=1
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_mode_map = { 'mode': 'active',
                           \ 'active_filetypes': [],
                           \ 'passive_filetypes': ['c', 'cpp'] }

" taglist
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_Close_On_Select = 1
let Tlist_Highlight_Tag_On_BufEnter = 0
let Tlist_Sort_Type = "name"

" vimux
let g:VimuxHeight = "33"

" map dwm keys ourself
let g:dwm_map_keys = 0

" https://github.com/vim-ruby/vim-ruby/issues/33
let g:ruby_path = ""

"-----------------------------------------------------------------------
" auto commands
"-----------------------------------------------------------------------

" expand tabs in C
autocmd FileType c,cpp set ts=4 sw=4 tw=79 expandtab et

" ruby completion
autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

" all remaining filetypes use syntaxcomplete
autocmd Filetype *
            \ if &omnifunc == "" |
            \   setlocal omnifunc=syntaxcomplete#Complete |
            \ endif

" remember the git root of the current project
autocmd VimEnter,BufEnter * let b:git_root_dir = system("git rev-parse --show-toplevel 2>/dev/null")[:-2]

" use project-level tagfiles
autocmd VimEnter,BufEnter * execute("set tags=./tags," . b:git_root_dir . "/tags")

" close nerdcommenter if its the last window
autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" delete fugitive buffers
autocmd BufReadPost fugitive://* set bufhidden=delete

"-----------------------------------------------------------------------
" custom functions
"-----------------------------------------------------------------------

" shortcut for file rename
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction

" git-grep function
if !exists('g:git_grep_command')
    let g:git_grep_command = 'git grep -n '
endif

function! s:GitGrep(terms)
    let expr = g:git_grep_command."'".a:terms."'"

    execute ":silent! lcd " . b:git_root_dir
    cgetexpr system(expr)
    execute ":silent! lcd " . expand("%:p:h")

    cwin
    echo 'Number of matches: ' . len(getqflist())
endfunction

function! s:GitGrepAsk()
    let term = escape(input("what do you want to seach?: "),  '\\/')
    call s:GitGrep(term)
endfunction

function! s:GitGrepWord()
    call s:GitGrep(expand("<cword>"))
endfunction

function! s:GitGrepWordBoundaries()
    call s:GitGrep("\\b".expand("<cword>")."\\b")
endfunction

command! -nargs=0 GitGrepWordBoundaries :call s:GitGrepWordBoundaries()
command! -nargs=0 GitGrepWord :call s:GitGrepWord()
command! -nargs=0 GitGrepAsk :call s:GitGrepAsk()

function! TabIsEmpty()
    let initial_win_num = winnr()
    let win_count = 0
    windo let win_count += len(expand('%'))
    exe initial_win_num . "wincmd w"
    if win_count == 0
        return 1
    else
        return 0
    endif
endfunction

function! DWMOpenFunc(action, line)
    if TabIsEmpty() == 0 && a:action == 'e'
        let filename = fnameescape(fnamemodify(a:line, ':p'))
        call DWM_New()
        execute ":silent! lcd " . b:git_root_dir
        execute 'edit' filename
    else
        call call('ctrlp#acceptfile', [a:action, a:line])
    endif
endfunction

let g:ctrlp_open_func = { 'files': 'DWMOpenFunc' }

"-----------------------------------------------------------------------
" key mappings
"-----------------------------------------------------------------------

" function keys
nnoremap <silent> <F1> :help<cr>
nnoremap <silent> <F2> :call RenameFile()<cr>
" nnoremap <F3> :SelectBuf<cr>
nnoremap <silent> <F4> :set invpaste<cr>
nnoremap <silent> <F5> :call system("ctags -R --c++-kinds=+p --fields=+iaS --extra=+q -f " . b:git_root_dir . "/tags " . b:git_root_dir)<cr>
nnoremap <silent> <F6> :TlistToggle<cr>
call togglebg#map("<F8>")
nnoremap <silent> <F9> :call RunRspecCurrentFileConque()<CR>
nnoremap <silent> <F10> :call RunRspecCurrentLineConque()<CR>
nnoremap <silent> <F11> :call RunRspecAllFilesConque()<CR>
nnoremap <silent> <F12> :GundoToggle<cr>

" window/tab management
map <S-Down>  <C-W><Down>
map <S-Up>    <C-W><Up>
map <S-Left>  <C-W><Left>
map <S-Right> <C-W><Right>

map  <silent> <C-Up> :tabprevious<cr>
imap <silent> <C-Up> <esc>:tabprevious<cr>a
map  <silent> <C-Down> :tabnext<cr>
imap <silent> <C-Down> <esc>:tabnext<cr>a

map  <silent> <C-c> <Plug>DWMClose
imap <silent> <C-c> <esc><Plug>DWMClose

map <silent> <bs> <Plug>DWMFocus

" map Ctrl-N to write+next
imap <C-n> <esc>:w<cr>:n<cr>
map <C-n> :w<cr>:n<cr>

" jump to next merge conflict
map <leader>fc /^<<<<<cr>

" (visual) paste without losing the register
xnoremap P Pgvy

" Bubble single lines
nmap <C-k> ddkP
nmap <C-j> ddp

" Bubble multiple lines
vmap <C-k> xkP`[V`]
vmap <C-j> xp`[V`]

" switch.vim
nnoremap - :Switch<cr>

" git grep for word under the cursor
nmap <silent> <leader>gw :GitGrepWordBoundaries<cr>
nmap <silent> <leader>gW :GitGrepWord<cr>
nmap <silent> <leader>gg :GitGrepAsk<cr>

" disable search hilight
nmap <silent> <leader>n :silent :nohlsearch<cr>

" cleanup whitespace terror
nmap <silent> <leader>ws :set et<cr>:retab<cr>:%s/\s\+$//g<cr>

" sort helper
vmap <silent> <leader>so :sort<cr>
vmap <silent> <leader>su :sort u<cr>

" git shortcuts
map <leader>gb :silent :Gblame<cr>

" add ruby debugger
nnoremap <silent> <leader>rad Orequire 'ruby-debug'; debugger<esc>

" splitjoin.vim
function! s:try(cmd, default)
    if exists(':' . a:cmd) && !v:count
        let tick = b:changedtick
        exe a:cmd
        if tick == b:changedtick
            execute 'normal! '.a:default
        endif
    else
        execute 'normal! '.v:count.a:default
    endif
endfunction

nnoremap <silent> J :<C-U>call <SID>try('SplitjoinJoin', 'J')<CR>
nnoremap <silent> S :<C-U>call <SID>try('SplitjoinSplit', 'S')<CR>

" Rename tabs to show tab# and # of viewports
if exists("+showtabline")
    function MyTabLine()
        let s = '' " complete tabline goes here
        " loop through each tab page
        for t in range(tabpagenr('$'))
            " select the highlighting for the buffer names
            if t + 1 == tabpagenr()
                let s .= '%#TabLineSel#'
            else
                let s .= '%#TabLine#'
            endif
            " empty space
            let s .= ' '
            " set the tab page number (for mouse clicks)
            let s .= '%' . (t + 1) . 'T'
            " set page number string
            let s .= t + 1 . ' '
            " get buffer names and statuses
            let n = ''  "temp string for buffer names while we loop and check buftype
            let m = 0 " &modified counter
            let bc = len(tabpagebuflist(t + 1))  "counter to avoid last ' '
            " loop through each buffer in a tab
            for b in tabpagebuflist(t + 1)
                " buffer types: quickfix gets a [Q], help gets [H]{base fname}
                " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
                if getbufvar( b, "&buftype" ) == 'help'
                    let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
                elseif getbufvar( b, "&buftype" ) == 'quickfix'
                    let n .= '[Q]'
                else
                    let n .= pathshorten(fnamemodify(bufname(b), ':~'))
                endif
                " check and ++ tab's &modified count
                if getbufvar( b, "&modified" )
                    let m += 1
                endif
                " no final ' ' added...formatting looks better done later
                if bc > 1
                    let n .= ' '
                endif
                let bc -= 1
            endfor
            " add modified label [n+] where n pages in tab are modified
            if m > 0
                "let s .= '[' . m . '+]'
                let s.= '+ '
            endif
            " add buffer names
            if n == ''
                let s .= '[No Name]'
            else
                let s .= n
            endif
            " switch to no underlining and add final space to buffer list
            "let s .= '%#TabLineSel#' . ' '
            let s .= ' '
        endfor
        " after the last tab fill with TabLineFill and reset tab page nr
        let s .= '%#TabLineFill#%T'
        " right-align the label to close the current tab page
        if tabpagenr('$') > 1
            let s .= '%=%#TabLine#%999XX'
        endif
        return s
    endfunction
    set stal=2
    set tabline=%!MyTabLine()
endif
